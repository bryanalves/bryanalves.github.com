<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bryan's Blah Blog</title><link>http://bryanalves.github.io/</link><description>Bryan's Blah Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 14 Aug 2016 00:00:00 +0000</lastBuildDate><atom:link href="http://bryanalves.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Using Chef Zero with Berkshelf</title><link>http://bryanalves.github.io/posts/2016-08-14-chef-zero-with-berkshelf/</link><pubDate>Sun, 14 Aug 2016 00:00:00 +0000</pubDate><guid>http://bryanalves.github.io/posts/2016-08-14-chef-zero-with-berkshelf/</guid><description>&lt;p>If you have a single machine that you want to control with Chef (for example, a single home server, or a server that you want to bootstrap to run chef-server for other things), Chef Zero can be a good tool to use. Chef Zero can be used by using the &lt;code>chef-client -z&lt;/code> command. This will treat your local working directory like a Chef server, so you&amp;rsquo;ll want the following directory structure:&lt;/p>
&lt;pre>&lt;code>cookbooks/
data_bags/
nodes/
roles/
environments/
&lt;/code>&lt;/pre>
&lt;p>Things are optional, but you&amp;rsquo;ll at least want &lt;code>cookbooks&lt;/code>.&lt;/p>
&lt;p>Actually, you don&amp;rsquo;t want cookbooks either.&lt;/p>
&lt;p>What?&lt;/p>
&lt;p>Well, when you are working with a real chef server, you don&amp;rsquo;t manually upload cookbooks to it, so why would you do the same with a virtual Chef server? Use Berkshelf like you normally do! Add &lt;code>cookbooks/&lt;/code> do your .gitignore file, create a separate directory to store your environment cookbook (I use &lt;code>site-cookbooks/&lt;/code>), and make a &lt;code>Berksfile&lt;/code> in the root directory that references it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>source &lt;span style="color:#e6db74">&amp;#39;https://supermarket.chef.io&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cookbook &lt;span style="color:#e6db74">&amp;#39;server-env&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">path&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;./site-cookbooks/server-env&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now your directory structure will look like this:&lt;/p>
&lt;pre>&lt;code>site-cookbooks/
server-env/
attributes/
recipes/
..
data_bags/
Berksfile
.gitignore
&lt;/code>&lt;/pre>
&lt;p>Add data_bags, environments, roles, as necessary. When you are ready, run &lt;code>berks vendor site-cookbooks&lt;/code> and the result will be a &lt;code>cookbooks/&lt;/code> directory ready for use by chef-zero. Run &lt;code>chef-client -z&lt;/code> and you are ready to converge your server complete with the full power of the chef supermarket in an easy to maintain way. Be sure to check in your &lt;code>Berksfile.lock&lt;/code> so that this is fully reproducible.&lt;/p>
&lt;p>The only real downside to this is that while Berksfile sort of works with multiple cookbooks, it can sometimes be awkward to resolve the dependency graph. For example, if you use this as a baseline for multiple servers, and have &lt;code>server1-env&lt;/code> and &lt;code>server2-env&lt;/code>, those cookbooks must have exact version matches on overlapping dependencies from the supermarket. This technique is only suitable for a single environment cookbook.&lt;/p></description></item><item><title>Easy ways to add files to LXC containers</title><link>http://bryanalves.github.io/posts/2015-07-09-easy-ways-to-add-files-to-lxc-containers/</link><pubDate>Thu, 09 Jul 2015 00:00:00 +0000</pubDate><guid>http://bryanalves.github.io/posts/2015-07-09-easy-ways-to-add-files-to-lxc-containers/</guid><description>&lt;p>When working with LXC containers, you occasionally need to transfer files from the host. If you are just using a normal file system, rooted somewhere like /var/lib/lxc, you can just copy the files in:&lt;/p>
&lt;pre>&lt;code>sudo cp file.blah /var/lib/lxc/test01/rootfs/home/blah/blah/blah
&lt;/code>&lt;/pre>
&lt;p>This kind of misses the point for 2 reasons. First of all, it&amp;rsquo;s assuming some things that can be considered &amp;ldquo;internal&amp;rdquo; to LXC, namely that file systems are rooted under something called {your_container_name}/rootfs. Furthermore, this won&amp;rsquo;t work if you are using different backends, like btrfs or zfs.&lt;/p>
&lt;p>The other reason why this isn&amp;rsquo;t good is that the file will be based on permissions and uid/gids from the host. A better way is to transfer using &lt;a href="http://linux.die.net/man/1/lxc-attach">lxc-attach&lt;/a>. For example:&lt;/p>
&lt;pre>&lt;code>&amp;lt;something_on_my_machine.sh lxc-attach -n $1 -- /bin/sh -c &amp;quot;/bin/cat &amp;gt; /target/on/lxc/guest&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>In case you aren&amp;rsquo;t familiar with the &amp;lt;file syntax, this is equivalent to:&lt;/p>
&lt;pre>&lt;code>cat something_on_my_machine.sh | lxc-attach -n $1 -- /bin/sh -c &amp;quot;/bin/cat &amp;gt; /target/on/lxc/guest&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Using a similar technique, you can pipe things into tar to transfer a bunch of files in bulk. Alternatively, you can transfer files from the container to the guest.&lt;/p>
&lt;p>The reason I&amp;rsquo;m being pedantic by using /bin/sh and /bin/cat is so that it will work more readily across a variety of OSes without having to worry about environment, having $PATH set, etc.&lt;/p></description></item><item><title>Access LXC containers by name from host</title><link>http://bryanalves.github.io/posts/2015-07-03-lxc-dns-on-host/</link><pubDate>Fri, 03 Jul 2015 00:00:00 +0000</pubDate><guid>http://bryanalves.github.io/posts/2015-07-03-lxc-dns-on-host/</guid><description>&lt;p>In a &lt;a href="http://bryanalves.github.io/2015/07/02/enabling-lxc-archlinux-with-systemd-networkd/">previous installment&lt;/a> we configured systemd-networkd and lxc to play nicely together, along with docker. There was one problem with that setup, which is that the host could not find containers by name. This post addresses that.&lt;/p>
&lt;h3 id="lxc_domain" >LXC_DOMAIN
&lt;span>
&lt;a href="#lxc_domain">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>On Archlinux at least, LXC_DOMAIN is empty by default. It&amp;rsquo;s a good idea to set this to something to help segregate the LXC containers. I used .lxc, &lt;a href="https://support.comodo.com/index.php?/Knowledgebase/Article/View/722/16/acceptable-internal-domain-names">even though I probably shouldn&amp;rsquo;t&lt;/a>&lt;/p>
&lt;h3 id="systemd-networkd-to-the-rescue" >systemd-networkd to the rescue
&lt;span>
&lt;a href="#systemd-networkd-to-the-rescue">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>In the previous post, I had mentioned that switching to systemd-networkd was probably just yak shaving. It pays off now though, as it makes handling upstream DNS a lot simpler with dnsmasq. First off, make sure that /etc/resolv.conf is a normal file, and &lt;strong>not&lt;/strong> symlinked to /run/systemd/resolve/resolv.conf as most guides suggest.&lt;/p>
&lt;p>Next, update dnsmasq.conf and add the following line:&lt;/p>
&lt;pre>&lt;code>resolv-file=/run/systemd/resolve/resolv.conf
&lt;/code>&lt;/pre>
&lt;p>Finally, add where your dnsmasq server listens to /etc/resolv.conf:&lt;/p>
&lt;pre>&lt;code>nameserver 10.0.3.1
&lt;/code>&lt;/pre>
&lt;p>Now, not only do you have access to LXC containers by name, but you have a local caching nameserver in place that you can do various thing with. This dnsmasq server does double-duty, so if you get too fancy it might be wise to separate concerns and create 2 dnsmasq instances, 1 for local caching and one solely for DNS/DHCP for LXC.&lt;/p></description></item><item><title>Enabling LXC on Archlinux with systemd-networkd</title><link>http://bryanalves.github.io/posts/2015-07-02-enabling-lxc-archlinux-with-systemd-networkd/</link><pubDate>Thu, 02 Jul 2015 00:00:00 +0000</pubDate><guid>http://bryanalves.github.io/posts/2015-07-02-enabling-lxc-archlinux-with-systemd-networkd/</guid><description>&lt;p>After playing around with docker a lot, I decided that it was time to spend some time with LXC as I tended to treat some of my docker containers like mini VMs anyway, especially when developing. I think a lot of the benefits of docker aren&amp;rsquo;t actually benefits, and I&amp;rsquo;ll be writing a follow-up post about that. To that end, I wanted to get LXC up and running.&lt;/p>
&lt;h3 id="whats-so-hard" >What&amp;rsquo;s so hard?
&lt;span>
&lt;a href="#whats-so-hard">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>I&amp;rsquo;m on a laptop with wireless, so I can&amp;rsquo;t just create a bridge and give IPs to containers from an upstream DHCP server. I needed to do NAT and essentially simulate/replicate how docker networking works. My goals were:&lt;/p>
&lt;ul>
&lt;li>DHCP or some other auto-assignment of IPs&lt;/li>
&lt;li>Containers can see each other by hostname&lt;/li>
&lt;li>Containers can see the host, and other nodes on the network&lt;/li>
&lt;li>Containers can see the internet&lt;/li>
&lt;li>Have all of this networking transparently work and persist across reboots&lt;/li>
&lt;/ul>
&lt;h3 id="general-approach" >General approach
&lt;span>
&lt;a href="#general-approach">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;ul>
&lt;li>Create a bridge interface&lt;/li>
&lt;li>Set up IP forwarding and masquerading&lt;/li>
&lt;li>Set up &lt;a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">dnsmasq&lt;/a> as a DHCP server&lt;/li>
&lt;li>profit?&lt;/li>
&lt;/ul>
&lt;p>In practice, these things didn&amp;rsquo;t work out so well.&lt;/p>
&lt;h3 id="problem-1-netctl" >Problem 1: netctl
&lt;span>
&lt;a href="#problem-1-netctl">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>&lt;a href="https://wiki.archlinux.org/index.php/Netctl">Netctl&lt;/a> was the recommended choice for a while on Archlinux systems. Now that systemd is taking over, it seems like more and more support is coming over to &lt;a href="https://wiki.archlinux.org/index.php/Systemd-networkd">systemd-networkd&lt;/a>. I asked for help in chat and 3 people immediately were like &amp;ldquo;why are you still using netctl?&amp;ldquo;I ran into a bit of trouble creating a netctl profile to create a bridge on boot. While I could have made this work (and the end solution would have had me not touch netctl at all), I ended up yak shaving and switching to systemd-networkd. It was mostly painless with 1 hiccup:&lt;/p>
&lt;h3 id="problem-2-systemd-networkd-ip-forwarding-defaults" >Problem 2: systemd-networkd ip forwarding defaults
&lt;span>
&lt;a href="#problem-2-systemd-networkd-ip-forwarding-defaults">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>By default, systemd-networkd does not honor &lt;em>sys.net.ipv4.ip_forward&lt;/em>. It instead creates a per-interface setting that defaults to no. This means that you need to explicitly set IPForward and IPMasquerade on your bridges. This includes the docker0 interface, which silently broke upon switching to systemd-networkd. It&amp;rsquo;s at least related to &lt;a href="https://bugs.freedesktop.org/show_bug.cgi?id=89509">this bug report&lt;/a>.&lt;/p>
&lt;h3 id="back-to-sanity" >Back to sanity
&lt;span>
&lt;a href="#back-to-sanity">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>So we are now on systemd-networkd, which more easily allows us to define bridges and we have something roughly like this:&lt;/p>
&lt;p>docker0.network&lt;/p>
&lt;pre>&lt;code>[Match]
Name=docker0
[Network]
IPForward=yes
&lt;/code>&lt;/pre>
&lt;p>wired.network&lt;/p>
&lt;pre>&lt;code>[Match]
Name=eth0
[Network]
DHCP=ipv4
[DHCP]
RouteMetric=10
&lt;/code>&lt;/pre>
&lt;p>wireless.network&lt;/p>
&lt;pre>&lt;code>[Match]
Name=wlan0
[Network]
DHCP=ipv4
[DHCP]
RouteMetric=20
&lt;/code>&lt;/pre>
&lt;h3 id="now-what" >Now what
&lt;span>
&lt;a href="#now-what">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>We haven&amp;rsquo;t even started making LXC work yet, let&amp;rsquo;s do that now. The first approach is to create a bridge interface for just LXC, so let&amp;rsquo;s do that&lt;/p>
&lt;p>lxcbr0.netdev&lt;/p>
&lt;pre>&lt;code>[NetDev]
Name=lxcbr0
Kind=bridge
&lt;/code>&lt;/pre>
&lt;p>lxcbr0.network&lt;/p>
&lt;pre>&lt;code>[Match]
Name=lxcbr0
[Network]
Address=10.0.100.1
IPForward=yes
IPMasquerade=yes
&lt;/code>&lt;/pre>
&lt;p>To use this, add something like the following to a config for your lxc container:&lt;/p>
&lt;pre>&lt;code>lxc.network.type = veth
lxc.network.flags = up
lxc.network.link = lxcbr0
&lt;/code>&lt;/pre>
&lt;p>This will work, but requires you to specify an IP for the container statically. Let&amp;rsquo;s add dnsmasq:&lt;/p>
&lt;pre>&lt;code>dhcp-range=10.0.100.100,10.0.100.200,12h
interface=lxcbr0
&lt;/code>&lt;/pre>
&lt;p>After this, you&amp;rsquo;ll notice that it still doesn&amp;rsquo;t work. You need an iptables rule to handle some checksum mistakes&lt;/p>
&lt;pre>&lt;code>iptables -t mangle -A POSTROUTING -o lxcbr0 -p udp -m udp --dport 68 -j CHECKSUM --checksum-fill
&lt;/code>&lt;/pre>
&lt;p>So far we&amp;rsquo;ve mostly got this handled by configuration files, but this checksum mangling is a manual step with no great place to automatically handle it. After a bit of looking around, Archlinux ships with a lxc-net systemd unit, which seems to do what I need. It&amp;rsquo;s a bit tricky to setup, and needs some interaction with systemd-networkd:&lt;/p>
&lt;ul>
&lt;li>The bridge can&amp;rsquo;t already exist, so we need to get rid of the lxcbr0.netdev file&lt;/li>
&lt;li>The bridge still needs systemd-networkd style masquerading, so we keep the lxcbr0.network file (remove the address line)&lt;/li>
&lt;/ul>
&lt;p>You also need to tell lxc-net that you want to use the bridge, so in /etc/default/lxc, change USE_LXC_BRIDGE to true. As a bonus, lxc-net handles dnsmasq for you, so you can get rid of that unit.&lt;/p>
&lt;h3 id="final-results" >Final results
&lt;span>
&lt;a href="#final-results">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>The units you should have enabled are:&lt;/p>
&lt;ul>
&lt;li>wpa_supplicant@wlan0&lt;/li>
&lt;li>systemd-networkd&lt;/li>
&lt;li>systemd-resolved&lt;/li>
&lt;li>lxc-net&lt;/li>
&lt;/ul>
&lt;p>/etc/systemd/network/docker0.network&lt;/p>
&lt;pre>&lt;code>[Match]
Name=docker0
[Network]
IPForward=yes
&lt;/code>&lt;/pre>
&lt;p>/etc/systemd/network/lxcbr0.network&lt;/p>
&lt;pre>&lt;code>[Match]
Name=lxcbr0
[Network]
IPForward=yes
IPMasquerade=yes
&lt;/code>&lt;/pre>
&lt;p>/etc/default/lxc&lt;/p>
&lt;pre>&lt;code>LXC_AUTO=&amp;quot;true&amp;quot;
BOOTGROUPS=&amp;quot;onboot,&amp;quot;
SHUTDOWNDELAY=5
OPTIONS=
STOPOPTS=&amp;quot;-a -A -s&amp;quot;
USE_LXC_BRIDGE=&amp;quot;true&amp;quot;
[ ! -f /etc/default/lxc-net ] || . /etc/default/lxc-net
&lt;/code>&lt;/pre>
&lt;p>On the next reboot, you should have:&lt;/p>
&lt;ul>
&lt;li>A working docker0 interface (if you are keeping docker around)&lt;/li>
&lt;li>An lxcbr0 interface with an IP associated with it&lt;/li>
&lt;li>Starting LXC containers should grab a natted IP automatically via DHCP&lt;/li>
&lt;/ul>
&lt;p>As a bonus, LXC containers can address each other by hostname, and docker containers and lxc containers can see each other by IP. Some more dnsmasq magic could maybe clear some of that up even further.&lt;/p>
&lt;p>The end resulting files make it seem like this is an easy problem, but the details of wireless not supporting actual bridging, netctl being flaky, systemd having unexpected ip_forwarding defaults, DHCP missing checksums, and lxc-net being a bit picky about how it gets started actually caused this exploration to take a few hours.&lt;/p></description></item><item><title>Upgrading to MiniTest</title><link>http://bryanalves.github.io/posts/2013-06-12-upgrading-to-minitest/</link><pubDate>Wed, 12 Jun 2013 00:00:00 +0000</pubDate><guid>http://bryanalves.github.io/posts/2013-06-12-upgrading-to-minitest/</guid><description>&lt;p>There are a lot of testing frameworks out there for Rails. A lot of work has been done in the community over the past few years, and it&amp;rsquo;s important to stay up to date with the latest in testing. Minitest is something that&amp;rsquo;s fairly old and stable at this point, but it provides a nice, clean, standardized testing interface with enough extensions to support other testing methodologies as well.&lt;/p>
&lt;h3 id="what-about-rspec" >What about RSpec?
&lt;span>
&lt;a href="#what-about-rspec">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>RSpec is great, and it&amp;rsquo;s full featured and awesome. If you are using RSpec, feel free to continue. Lots of things have support for it, and there&amp;rsquo;s a great environment around RSpec.&lt;/p>
&lt;h3 id="minitestunit-or-minitestspec" >MiniTest::Unit or MiniTest::Spec
&lt;span>
&lt;a href="#minitestunit-or-minitestspec">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Minitest&amp;rsquo;s biggest strength is it&amp;rsquo;s ability to straddle the xUnit/spec line, seamlessly transitioning between the two. In my opinion, spec-style tests are better and the way to go. They more cleanly and succinctly express intention of the test. However, they aren&amp;rsquo;t always appropriate, and falling back to standard xUnit assertions is very helpful.&lt;/p>
&lt;p>Additionally, MiniTest::Spec gets surprisingly close to the ability of RSpec, especially with some of the extra expectation gems.&lt;/p>
&lt;h3 id="extension-versus-replacement" >Extension versus replacement
&lt;span>
&lt;a href="#extension-versus-replacement">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Things like shoulda attempted to make testing better by providing alternatives. With the exception of RSpec, these alternatives have simply diluted the choice of testing frameworks. MiniTest is different in that it&amp;rsquo;s modular and plugin-based, so everything stays coherent, even with significant additions. There&amp;rsquo;s a large list of extensions available on &lt;a href="https://github.com/seattlerb/minitest">Github&lt;/a>.&lt;/p>
&lt;h3 id="the-way-forward" >The way forward
&lt;span>
&lt;a href="#the-way-forward">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>If you like spec-style tests, then gradually start going file-by-file through your test suite and do the conversion. Once you are done, you get the satisfaction of using a single testing tool, more readable tests, and probably faster test execution.&lt;/p></description></item><item><title>Languages to pay attention to</title><link>http://bryanalves.github.io/posts/2013-04-20-languages-to-pay-attention-to/</link><pubDate>Sat, 20 Apr 2013 00:00:00 +0000</pubDate><guid>http://bryanalves.github.io/posts/2013-04-20-languages-to-pay-attention-to/</guid><description>&lt;p>So now that we&amp;rsquo;ve established why languages and platforms are powerful, let&amp;rsquo;s take a look at some languages that you should pay attention to:&lt;/p>
&lt;h3 id="c" >C
&lt;span>
&lt;a href="#c">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>C trades everything else for speed. Most languages have bindings to C, so if you need to drop down to C in order to get fast things done, you can. It&amp;rsquo;s development environment is good enough, and it&amp;rsquo;s just what you use if you want to take something and make it faster.&lt;/p>
&lt;p>If you need to write fast code, or convert existing code to fast code, you are likely going to end up working in C, at least a little bit.&lt;/p>
&lt;h3 id="java" >Java
&lt;span>
&lt;a href="#java">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Java is ubiquitous. There&amp;rsquo;s a huge community around it, and a lot of work has gone into it &amp;ndash; and the JVM &amp;ndash; to make it a fast and reliable platform. With this huge community comes a lot of junk to sift through, and swaths of under-performing engineers and companies, but there are a lot of gems to learn from this community.&lt;/p>
&lt;h3 id="ruby" >Ruby
&lt;span>
&lt;a href="#ruby">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Speaking of gems, Ruby has taken rails and run with it, turning it into a successful platform that gets a lot of things right. Gems and bundler have made it easy for the community to grow and distribute shared code.&lt;/p>
&lt;h3 id="python" >Python
&lt;span>
&lt;a href="#python">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Like Ruby, Python has become a mainstream general purpose language. SciPy, NumPy, and Django have led the way in the growth of the community. Pypy is becoming a leader in code execution and JIT, concepts that will hopefully become more universally usable in the months and years to come.&lt;/p>
&lt;h3 id="javascript" >Javascript
&lt;span>
&lt;a href="#javascript">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>This introduction of JIT and other advanced optimization techniques in V8 has made Javascript become a prevalent language not only in the client-side, but also in the server-side. Node has helped develop a whole new class of full-stack engineers; engineers that only need 1 primary language to do &lt;em>everything&lt;/em>. While the merits of actually doing this are arguable, there is a lot of good work coming out of this camp, including pushes for event-based programming, especially concurrency concepts. A lot of these have been known about in acadamia for a while, but now there are some practical implementations of them.&lt;/p>
&lt;h3 id="scala" >Scala
&lt;span>
&lt;a href="#scala">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Where Java fails, Scala hopes to succeed. Java has helped the development of the JVM, which other people are now trying to build upon to build a better Java. Scala adds a robust typesystem and a whole host of other language features to Java that are poised to allow developers to write better code. Scala is another example of taking concepts from acadamia and putting them in a package that regular developers can use.&lt;/p>
&lt;h3 id="clojure" >Clojure
&lt;span>
&lt;a href="#clojure">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Lisp on the JVM. Lisp&amp;rsquo;s community is small, and sometimes it&amp;rsquo;s performance is suboptimal. By tapping into the JVM, Clojure hopes to get both the peformance and community behind it, turning Lisp into a mainstream powerhouse. Rich Hickey is a brilliant man, and even if Clojure doesn&amp;rsquo;t succeed, he should be listened to, as he has very pragmatic, very well thought out ideas about how development should be.&lt;/p>
&lt;h3 id="go" >Go
&lt;span>
&lt;a href="#go">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Google&amp;rsquo;s systems programming language, Go allows development of systems that would traditionally be written in C (web servers, messaging systems, etc), without the hassle of memory management. Furthermore, it provides a lot of essential tools, namely channels, that allow massively concurrent systems to be built easily and with less bugs. Erlang had this market a long time ago, but now Go has both a more traditional code syntax, as opposed to Erlang&amp;rsquo;s prolog-inspired syntax, and the support of a major company, Google. Go is also more concerned with performance than Erlang ever was.&lt;/p>
&lt;h3 id="closing-thoughts" >Closing thoughts
&lt;span>
&lt;a href="#closing-thoughts">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>This list is certainly biased, and are things that I care about. The goal of this list is to expose yourself to a variety of languages that will help you incorporate concepts into your daily work, whatever the language. This list is also very unix-centric; there is no C# for example. The goal of this list is to encourage you to learn some new concepts and hopefully make yourself a better programmer. Exposing yourself to new skills and new methods from other communities is the best way to make yourself better. Most importantly, know the right tool for the job, and understand what makes something the right tool for a given job.&lt;/p></description></item><item><title>What makes a good programming language</title><link>http://bryanalves.github.io/posts/2013-04-06-what-makes-a-good-programming-language/</link><pubDate>Sat, 06 Apr 2013 00:00:00 +0000</pubDate><guid>http://bryanalves.github.io/posts/2013-04-06-what-makes-a-good-programming-language/</guid><description>&lt;p>There are a lot of programming languages available, and a lot of reasons to pick one over the other.&lt;/p>
&lt;h2 id="its-all-about-power-right" >It&amp;rsquo;s all about power, right?
&lt;span>
&lt;a href="#its-all-about-power-right">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>One thing that people discover as they work with languages is that some languages are more powerful than others. What does this mean exactly? Aren&amp;rsquo;t most languages Turing complete? At some level, it&amp;rsquo;s a matter of expressivity. Some languages are better at expressing concepts succinctly than others. Lisp is a good example of this. It&amp;rsquo;s extreme ability to metaprogram makes it the most expressive language available.&lt;/p>
&lt;p>Why then isn&amp;rsquo;t it regularly used everywhere? If power and expressivity were all that mattered, then Lisp would dominate everything.&lt;/p>
&lt;h2 id="library-and-3rd-party-support" >Library and 3rd party support
&lt;span>
&lt;a href="#library-and-3rd-party-support">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Another critical component of a language is it&amp;rsquo;s library support. Sure, Lisp might allow someone to write a web server in only a few dozen lines of code, but this reinvention of the wheel misses the point. Ruby developers will just add some gems, Python developers will hit up PyPi, Perl developers will go to CPAN, etc. Lisp has a set of libraries available, but it&amp;rsquo;s not nearly as robust as what&amp;rsquo;s provided by other, more popular languages.&lt;/p>
&lt;p>This is one of the reasons why Node has taken off; it embraced library support immediately, and npm has provided a rich environment for developers to work with.&lt;/p>
&lt;h2 id="development-environment" >Development environment
&lt;span>
&lt;a href="#development-environment">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Another important aspect is strength of development environment. This is an area where Lisp shines; it&amp;rsquo;s ability to be metaprogrammed makes things like Emacs work wonderfully with it. Here also is why Java and .NET are prevalent; Eclipse, NetBeans, and Visual Studio make up for other lackluster components of the languages.&lt;/p>
&lt;h2 id="consistent-implementation" >Consistent implementation
&lt;span>
&lt;a href="#consistent-implementation">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Lisp doesn&amp;rsquo;t really have a de facto implementation. Common Lisp is a standard, but implementation of the standard isn&amp;rsquo;t very widespread. This makes an already small community become somewhat fractured around implementatons. Python and Ruby don&amp;rsquo;t have this problem because they do have a de facto implementation, and that de facto implementation (CPython, and MRI) occupies a huge majority of the market. PyPy, JRuby, etc. are useful and great, but they don&amp;rsquo;t drive progress of the language. They also still identify at Python or Ruby programmers.&lt;/p>
&lt;p>On the contrary, SBCL and Clojure don&amp;rsquo;t have this property.&lt;/p>
&lt;h2 id="community" >Community
&lt;span>
&lt;a href="#community">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>This is a bit of a chicken and egg problem. Some languages are better than others because their communities are larger. Have a problem? You&amp;rsquo;ll be much more likely to get a response from a community of hundreds of thousands of developers than a community with orders of magnitude less than that.&lt;/p>
&lt;h2 id="what-about-other-languages" >What about other languages?
&lt;span>
&lt;a href="#what-about-other-languages">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>So far I&amp;rsquo;ve primarily talked about Lisp, Ruby, and Python. Lisp is a powerful language, but it misses out on library support, and a consistent implementation. Ruby and Python are nearly as powerful, have tremendous libraries, reasonable development tools, and consistent implementations. What about other languages? Well, that&amp;rsquo;s an analysis for another time.&lt;/p>
&lt;h2 id="what-does-this-mean" >What does this mean?
&lt;span>
&lt;a href="#what-does-this-mean">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>There&amp;rsquo;s more to a language than just it&amp;rsquo;s syntax, how easy it is to install, or what features it has. Everything mentioned here matters. As a perfect counter-example, consider Javascript. From a language strength point of view, it&amp;rsquo;s not very great. It&amp;rsquo;s syntax is bad enough that CoffeeScript was written as a preprocessor for the language. However, it&amp;rsquo;s still a wildly popular language, and that is because of a large community, among other things.&lt;/p>
&lt;h2 id="how-do-i-make-my-language-popular" >How do I make my language popular?
&lt;span>
&lt;a href="#how-do-i-make-my-language-popular">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>As a language developer, you must:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Make it easy for reusable libraries to be built, distributed, and publicized. Gems, Pypi, CPAN, NPM, etc. should all be motivations. If your language doesn&amp;rsquo;t have something that compares, you likely won&amp;rsquo;t be successful.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Make development easy. Ensure that text editor support is good. Users of Vim or Emacs should want to use your language. If appropriate, work well with Eclipse or NetBeans. If you are huge like Microsoft, build your own world class IDE. Ensure that debugging support is good. If developers have to rely solely on print statements, you are in trouble.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Take control of your implementation. Do more than just release a spec for your language; release an implementation, and make sure it&amp;rsquo;s good.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Build the community, and market your language. Javascript might be bad, but node marketed itself, and now it&amp;rsquo;s huge. Make sure you are active in programming circles, attracting people. Have a presence on IRC. Have mailing lists. You want people more than using your language, you want them creating a community around it. Your goal should be to have a conference named after your language that people aspire to go to.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>About Me</title><link>http://bryanalves.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://bryanalves.github.io/about/</guid><description>&lt;p>My name is Bryan Alves, and I&amp;rsquo;m a software engineer in the Boston area. I mostly work on web applications using a variety of technologies. Here are some links for more information about me:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.facebook.com/bryanalves">Facebook&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.github.com/bryanalves">Github&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.twitter.com/bryanalves">Twitter&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.linkedin.com/in/bryanalves">LinkedIn&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.dropbox.com/s/dcrkchfg50esc29/resume.pdf?raw=1">Resume&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.dropbox.com/s/xuxtrtax3nk807u/A9806FD1E6309118.gpg?dl=1">GPG&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>